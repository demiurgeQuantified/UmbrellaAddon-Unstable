---@meta _

---(Not exposed)
---The Boolean class wraps a value of the primitive type
--- boolean in an object. An object of type
--- Boolean contains a single field whose type is
--- boolean.
---
--- In addition, this class provides many methods for
--- converting a boolean to a String and a
--- String to a boolean, as well as other
--- constants and methods useful when dealing with a
--- boolean.
---
--- This is a value-based
--- class; programmers should treat instances that are
--- equal as interchangeable and should not
--- use instances for synchronization, or unpredictable behavior may
--- occur. For example, in a future release, synchronization may fail.
---@class Boolean

---(Not exposed)
---The Byte class wraps a value of primitive type byte
--- in an object.  An object of type Byte contains a single
--- field whose type is byte.
---
--- In addition, this class provides several methods for converting
--- a byte to a String and a String to a
--- byte, as well as other constants and methods useful when dealing
--- with a byte.
---
--- This is a value-based
--- class; programmers should treat instances that are
--- equal as interchangeable and should not
--- use instances for synchronization, or unpredictable behavior may
--- occur. For example, in a future release, synchronization may fail.
---@class Byte

---(Not exposed)
---A CharSequence is a readable sequence of char values. This
--- interface provides uniform, read-only access to many different kinds of
--- char sequences.
--- A char value represents a character in the Basic
--- Multilingual Plane (BMP) or a surrogate. Refer to Unicode Character Representation for details.
---
---  This interface does not refine the general contracts of the equals and hashCode methods. The result of testing two objects
--- that implement CharSequence for equality is therefore, in general, undefined.
--- Each object may be implemented by a different class, and there
--- is no guarantee that each class will be capable of testing its instances
--- for equality with those of the other.  It is therefore inappropriate to use
--- arbitrary CharSequence instances as elements in a set or as keys in
--- a map.
---@class CharSequence

---(Not exposed)
---The Character class wraps a value of the primitive
--- type char in an object. An object of class
--- Character contains a single field whose type is
--- char.
---
--- In addition, this class provides a large number of static methods for
--- determining a character's category (lowercase letter, digit, etc.)
--- and for converting characters from uppercase to lowercase and vice
--- versa.
---
--- Unicode Conformance
---
--- The fields and methods of class Character are defined in terms
--- of character information from the Unicode Standard, specifically the
--- UnicodeData file that is part of the Unicode Character Database.
--- This file specifies properties including name and category for every
--- assigned Unicode code point or character range. The file is available
--- from the Unicode Consortium at
--- http://www.unicode.org.
---
--- Character information is based on the Unicode Standard, version 13.0.
---
--- The Java platform has supported different versions of the Unicode
--- Standard over time. Upgrades to newer versions of the Unicode Standard
--- occurred in the following Java releases, each indicating the new version:
---
--- Shows Java releases and supported Unicode versions
---
--- Java release
---     Unicode version
---
---
--- Java SE 15
---     Unicode 13.0
--- Java SE 13
---     Unicode 12.1
--- Java SE 12
---     Unicode 11.0
--- Java SE 11
---     Unicode 10.0
--- Java SE 9
---     Unicode 8.0
--- Java SE 8
---     Unicode 6.2
--- Java SE 7
---     Unicode 6.0
--- Java SE 5.0
---     Unicode 4.0
--- Java SE 1.4
---     Unicode 3.0
--- JDK 1.1
---     Unicode 2.0
--- JDK 1.0.2
---     Unicode 1.1.5
---
---
--- Variations from these base Unicode versions, such as recognized appendixes,
--- are documented elsewhere.
--- Unicode Character Representations
---
--- The char data type (and therefore the value that a
--- Character object encapsulates) are based on the
--- original Unicode specification, which defined characters as
--- fixed-width 16-bit entities. The Unicode Standard has since been
--- changed to allow for characters whose representation requires more
--- than 16 bits.  The range of legal code points is now
--- U+0000 to U+10FFFF, known as Unicode scalar value.
--- (Refer to the
--- definition of the U+n notation in the Unicode
--- Standard.)
---
--- The set of characters from U+0000 to U+FFFF is
--- sometimes referred to as the Basic Multilingual Plane (BMP).
--- Characters whose code points are greater
--- than U+FFFF are called supplementary characters.  The Java
--- platform uses the UTF-16 representation in char arrays and
--- in the String and StringBuffer classes. In
--- this representation, supplementary characters are represented as a pair
--- of char values, the first from the high-surrogates
--- range, (&#92;uD800-&#92;uDBFF), the second from the
--- low-surrogates range (&#92;uDC00-&#92;uDFFF).
---
--- A char value, therefore, represents Basic
--- Multilingual Plane (BMP) code points, including the surrogate
--- code points, or code units of the UTF-16 encoding. An
--- int value represents all Unicode code points,
--- including supplementary code points. The lower (least significant)
--- 21 bits of int are used to represent Unicode code
--- points and the upper (most significant) 11 bits must be zero.
--- Unless otherwise specified, the behavior with respect to
--- supplementary characters and surrogate char values is
--- as follows:
---
---
--- The methods that only accept a char value cannot support
--- supplementary characters. They treat char values from the
--- surrogate ranges as undefined characters. For example,
--- Character.isLetter('\uD840') returns false, even though
--- this specific value if followed by any low-surrogate value in a string
--- would represent a letter.
---
--- The methods that accept an int value support all
--- Unicode characters, including supplementary characters. For
--- example, Character.isLetter(0x2F81A) returns
--- true because the code point value represents a letter
--- (a CJK ideograph).
---
---
--- In the Java SE API documentation, Unicode code point is
--- used for character values in the range between U+0000 and U+10FFFF,
--- and Unicode code unit is used for 16-bit
--- char values that are code units of the UTF-16
--- encoding. For more information on Unicode terminology, refer to the
--- Unicode Glossary.
---
--- This is a value-based
--- class; programmers should treat instances that are
--- equal as interchangeable and should not
--- use instances for synchronization, or unpredictable behavior may
--- occur. For example, in a future release, synchronization may fail.
---@class Character

---(Not exposed)
---Instances of the class Class represent classes and
--- interfaces in a running Java application. An enum class and a record
--- class are kinds of class; an annotation interface is a kind of
--- interface. Every array also belongs to a class that is reflected as
--- a Class object that is shared by all arrays with the same
--- element type and number of dimensions.  The primitive Java types
--- (boolean, byte, char, short,
--- int, long, float, and double), and the
--- keyword void are also represented as Class objects.
---
---  Class has no public constructor. Instead a Class
--- object is constructed automatically by the Java Virtual Machine when
--- a class is derived from the bytes of a class file through
--- the invocation of one of the following methods:
---
---  ClassLoader::defineClass
---  java.lang.invoke.MethodHandles.Lookup::defineClass
---  java.lang.invoke.MethodHandles.Lookup::defineHiddenClass
---
---
---  The methods of class Class expose many characteristics of a
--- class or interface. Most characteristics are derived from the class
--- file that the class loader passed to the Java Virtual Machine or
--- from the class file passed to Lookup::defineClass
--- or Lookup::defineHiddenClass.
--- A few characteristics are determined by the class loading environment
--- at run time, such as the module returned by getModule().
---
---  The following example uses a Class object to print the
--- class name of an object:
---
---
---     void printClassName(Object obj) {
---         System.out.println("The class of " + obj +
---                            " is " + obj.getClass().getName());
---     }
---
---
--- It is also possible to get the Class object for a named
--- class or interface (or for void) using a class literal.
--- For example:
---
---
---     System.out.println("The name of class Foo is: "+Foo.class.getName());
---
---
---  Some methods of class Class expose whether the declaration of
--- a class or interface in Java source code was enclosed within
--- another declaration. Other methods describe how a class or interface
--- is situated in a nest. A nest is a set of
--- classes and interfaces, in the same run-time package, that
--- allow mutual access to their private members.
--- The classes and interfaces are known as nestmates.
--- One nestmate acts as the
--- nest host, and enumerates the other nestmates which
--- belong to the nest; each of them in turn records it as the nest host.
--- The classes and interfaces which belong to a nest, including its host, are
--- determined when
--- class files are generated, for example, a Java compiler
--- will typically record a top-level class as the host of a nest where the
--- other members are the classes and interfaces whose declarations are
--- enclosed within the top-level class declaration.
---
---  A class or interface created by the invocation of
--- Lookup::defineHiddenClass is a hidden
--- class or interface.
--- All kinds of class, including enum classes and record classes, may be
--- hidden classes; all kinds of interface, including annotation interfaces,
--- may be hidden interfaces.
---
--- The name of a hidden class or interface is
--- not a binary name,
--- which means the following:
---
--- A hidden class or interface cannot be referenced by the constant pools
---     of other classes and interfaces.
--- A hidden class or interface cannot be described in
---     nominal form by
---     Class::describeConstable,
---     ClassDesc::of, or
---     ClassDesc::ofDescriptor.
--- A hidden class or interface cannot be discovered by Class::forName
---     or ClassLoader::loadClass.
---
---
--- A hidden class or interface is never an array class, but may be
--- the element type of an array. In all other respects, the fact that
--- a class or interface is hidden has no bearing on the characteristics
--- exposed by the methods of class Class.
---@class Class<T>

---(Not exposed)
---A nominal descriptor for an
--- enum constant.
---@class Enum.EnumDesc<E: Enum<E>>

---(Not exposed)
---The class Exception and its subclasses are a form of
--- Throwable that indicates conditions that a reasonable
--- application might want to catch.
---
--- The class Exception and any subclasses that are not also
--- subclasses of RuntimeException are checked
--- exceptions.  Checked exceptions need to be declared in a
--- method or constructor's throws clause if they can be thrown
--- by the execution of the method or constructor and propagate outside
--- the method or constructor boundary.
---@class Exception

---(Not exposed)
---The Runnable interface should be implemented by any
--- class whose instances are intended to be executed by a thread. The
--- class must define a method of no arguments called run.
---
--- This interface is designed to provide a common protocol for objects that
--- wish to execute code while they are active. For example,
--- Runnable is implemented by class Thread.
--- Being active simply means that a thread has been started and has not
--- yet been stopped.
---
--- In addition, Runnable provides the means for a class to be
--- active while not subclassing Thread. A class that implements
--- Runnable can run without subclassing Thread
--- by instantiating a Thread instance and passing itself in
--- as the target.  In most cases, the Runnable interface should
--- be used if you are only planning to override the run()
--- method and no other Thread methods.
--- This is important because classes should not be subclassed
--- unless the programmer intends on modifying or enhancing the fundamental
--- behavior of the class.
---@class Runnable

---(Not exposed)
---The Short class wraps a value of primitive type
--- short in an object.  An object of type Short contains a
--- single field whose type is short.
---
--- In addition, this class provides several methods for converting
--- a short to a String and a String to a
--- short, as well as other constants and methods useful when
--- dealing with a short.
---
--- This is a value-based
--- class; programmers should treat instances that are
--- equal as interchangeable and should not
--- use instances for synchronization, or unpredictable behavior may
--- occur. For example, in a future release, synchronization may fail.
---@class Short

---(Not exposed)
---An element in a stack trace, as returned by Throwable.getStackTrace().  Each element represents a single stack frame.
--- All stack frames except for the one at the top of the stack represent
--- a method invocation.  The frame at the top of the stack represents the
--- execution point at which the stack trace was generated.  Typically,
--- this is the point at which the throwable corresponding to the stack trace
--- was created.
---@class StackTraceElement

---(Not exposed)
---The String class represents character strings. All
--- string literals in Java programs, such as "abc", are
--- implemented as instances of this class.
---
--- Strings are constant; their values cannot be changed after they
--- are created. String buffers support mutable strings.
--- Because String objects are immutable they can be shared. For example:
---
---     String str = "abc";
---
--- is equivalent to:
---
---     char data[] = {'a', 'b', 'c'};
---     String str = new String(data);
---
--- Here are some more examples of how strings can be used:
---
---     System.out.println("abc");
---     String cde = "cde";
---     System.out.println("abc" + cde);
---     String c = "abc".substring(2, 3);
---     String d = cde.substring(1, 2);
---
---
--- The class String includes methods for examining
--- individual characters of the sequence, for comparing strings, for
--- searching strings, for extracting substrings, and for creating a
--- copy of a string with all characters translated to uppercase or to
--- lowercase. Case mapping is based on the Unicode Standard version
--- specified by the Character class.
---
--- The Java language provides special support for the string
--- concatenation operator ( + ), and for conversion of
--- other objects to strings. For additional information on string
--- concatenation and conversion, see The Java Language Specification.
---
---  Unless otherwise noted, passing a null argument to a constructor
--- or method in this class will cause a NullPointerException to be
--- thrown.
---
--- A String represents a string in the UTF-16 format
--- in which supplementary characters are represented by surrogate
--- pairs (see the section Unicode
--- Character Representations in the Character class for
--- more information).
--- Index values refer to char code units, so a supplementary
--- character uses two positions in a String.
--- The String class provides methods for dealing with
--- Unicode code points (i.e., characters), in addition to those for
--- dealing with Unicode code units (i.e., char values).
---
--- Unless otherwise noted, methods for comparing Strings do not take locale
--- into account.  The Collator class provides methods for
--- finer-grain, locale-sensitive String comparison.
---@class String

---(Not exposed)
---A thread-safe, mutable sequence of characters.
--- A string buffer is like a String, but can be modified. At any
--- point in time it contains some particular sequence of characters, but
--- the length and content of the sequence can be changed through certain
--- method calls.
---
--- String buffers are safe for use by multiple threads. The methods
--- are synchronized where necessary so that all the operations on any
--- particular instance behave as if they occur in some serial order
--- that is consistent with the order of the method calls made by each of
--- the individual threads involved.
---
--- The principal operations on a StringBuffer are the
--- append and insert methods, which are
--- overloaded so as to accept data of any type. Each effectively
--- converts a given datum to a string and then appends or inserts the
--- characters of that string to the string buffer. The
--- append method always adds these characters at the end
--- of the buffer; the insert method adds the characters at
--- a specified point.
---
--- For example, if z refers to a string buffer object
--- whose current contents are "start", then
--- the method call z.append("le") would cause the string
--- buffer to contain "startle", whereas
--- z.insert(4, "le") would alter the string buffer to
--- contain "starlet".
---
--- In general, if sb refers to an instance of a StringBuffer,
--- then sb.append(x) has the same effect as
--- sb.insert(sb.length(), x).
---
--- Whenever an operation occurs involving a source sequence (such as
--- appending or inserting from a source sequence), this class synchronizes
--- only on the string buffer performing the operation, not on the source.
--- Note that while StringBuffer is designed to be safe to use
--- concurrently from multiple threads, if the constructor or the
--- append or insert operation is passed a source sequence
--- that is shared across threads, the calling code must ensure
--- that the operation has a consistent and unchanging view of the source
--- sequence for the duration of the operation.
--- This could be satisfied by the caller holding a lock during the
--- operation's call, by using an immutable source sequence, or by not
--- sharing the source sequence across threads.
---
--- Every string buffer has a capacity. As long as the length of the
--- character sequence contained in the string buffer does not exceed
--- the capacity, it is not necessary to allocate a new internal
--- buffer array. If the internal buffer overflows, it is
--- automatically made larger.
---
--- Unless otherwise noted, passing a null argument to a constructor
--- or method in this class will cause a NullPointerException to be
--- thrown.
---
--- As of  release JDK 5, this class has been supplemented with an equivalent
--- class designed for use by a single thread, StringBuilder.  The
--- StringBuilder class should generally be used in preference to
--- this one, as it supports all of the same operations but it is faster, as
--- it performs no synchronization.
---@class StringBuffer

---(Not exposed)
---A mutable sequence of characters.  This class provides an API compatible
--- with StringBuffer, but with no guarantee of synchronization.
--- This class is designed for use as a drop-in replacement for
--- StringBuffer in places where the string buffer was being
--- used by a single thread (as is generally the case).   Where possible,
--- it is recommended that this class be used in preference to
--- StringBuffer as it will be faster under most implementations.
---
--- The principal operations on a StringBuilder are the
--- append and insert methods, which are
--- overloaded so as to accept data of any type. Each effectively
--- converts a given datum to a string and then appends or inserts the
--- characters of that string to the string builder. The
--- append method always adds these characters at the end
--- of the builder; the insert method adds the characters at
--- a specified point.
---
--- For example, if z refers to a string builder object
--- whose current contents are "start", then
--- the method call z.append("le") would cause the string
--- builder to contain "startle", whereas
--- z.insert(4, "le") would alter the string builder to
--- contain "starlet".
---
--- In general, if sb refers to an instance of a StringBuilder,
--- then sb.append(x) has the same effect as
--- sb.insert(sb.length(), x).
---
--- Every string builder has a capacity. As long as the length of the
--- character sequence contained in the string builder does not exceed
--- the capacity, it is not necessary to allocate a new internal
--- buffer. If the internal buffer overflows, it is automatically made larger.
---
--- Instances of StringBuilder are not safe for
--- use by multiple threads. If such synchronization is required then it is
--- recommended that StringBuffer be used.
---
--- Unless otherwise noted, passing a null argument to a constructor
--- or method in this class will cause a NullPointerException to be
--- thrown.
---@class StringBuilder

---(Not exposed)
---A thread is a thread of execution in a program. The Java
--- Virtual Machine allows an application to have multiple threads of
--- execution running concurrently.
---
--- Every thread has a priority. Threads with higher priority are
--- executed in preference to threads with lower priority. Each thread
--- may or may not also be marked as a daemon. When code running in
--- some thread creates a new Thread object, the new
--- thread has its priority initially set equal to the priority of the
--- creating thread, and is a daemon thread if and only if the
--- creating thread is a daemon.
---
--- When a Java Virtual Machine starts up, there is usually a single
--- non-daemon thread (which typically calls the method named
--- main of some designated class). The Java Virtual
--- Machine continues to execute threads until either of the following
--- occurs:
---
--- The exit method of class Runtime has been
---     called and the security manager has permitted the exit operation
---     to take place.
--- All threads that are not daemon threads have died, either by
---     returning from the call to the run method or by
---     throwing an exception that propagates beyond the run
---     method.
---
---
--- There are two ways to create a new thread of execution. One is to
--- declare a class to be a subclass of Thread. This
--- subclass should override the run method of class
--- Thread. An instance of the subclass can then be
--- allocated and started. For example, a thread that computes primes
--- larger than a stated value could be written as follows:
---
---     class PrimeThread extends Thread {
---         long minPrime;
---         PrimeThread(long minPrime) {
---             this.minPrime = minPrime;
---         }
---
---         public void run() {
---             // compute primes larger than minPrime
---              . . .
---         }
---     }
---
---
--- The following code would then create a thread and start it running:
---
---     PrimeThread p = new PrimeThread(143);
---     p.start();
---
---
--- The other way to create a thread is to declare a class that
--- implements the Runnable interface. That class then
--- implements the run method. An instance of the class can
--- then be allocated, passed as an argument when creating
--- Thread, and started. The same example in this other
--- style looks like the following:
---
---     class PrimeRun implements Runnable {
---         long minPrime;
---         PrimeRun(long minPrime) {
---             this.minPrime = minPrime;
---         }
---
---         public void run() {
---             // compute primes larger than minPrime
---              . . .
---         }
---     }
---
---
--- The following code would then create a thread and start it running:
---
---     PrimeRun p = new PrimeRun(143);
---     new Thread(p).start();
---
---
--- Every thread has a name for identification purposes. More than
--- one thread may have the same name. If a name is not specified when
--- a thread is created, a new name is generated for it.
---
--- Unless otherwise noted, passing a null argument to a constructor
--- or method in this class will cause a NullPointerException to be
--- thrown.
---@class Thread

---(Not exposed)
---This class provides thread-local variables.  These variables differ from
--- their normal counterparts in that each thread that accesses one (via its
--- get or set method) has its own, independently initialized
--- copy of the variable.  ThreadLocal instances are typically private
--- static fields in classes that wish to associate state with a thread (e.g.,
--- a user ID or Transaction ID).
---
--- For example, the class below generates unique identifiers local to each
--- thread.
--- A thread's id is assigned the first time it invokes ThreadId.get()
--- and remains unchanged on subsequent calls.
---
--- import java.util.concurrent.atomic.AtomicInteger;
---
--- public class ThreadId {
---     // Atomic integer containing the next thread ID to be assigned
---     private static final AtomicInteger nextId = new AtomicInteger(0);
---
---     // Thread local variable containing each thread's ID
---     private static final ThreadLocal<Integer> threadId =
---         new ThreadLocal<Integer>() {
---             &#64;Override protected Integer initialValue() {
---                 return nextId.getAndIncrement();
---         }
---     };
---
---     // Returns the current thread's unique ID, assigning it if necessary
---     public static int get() {
---         return threadId.get();
---     }
--- }
---
--- Each thread holds an implicit reference to its copy of a thread-local
--- variable as long as the thread is alive and the ThreadLocal
--- instance is accessible; after a thread goes away, all of its copies of
--- thread-local instances are subject to garbage collection (unless other
--- references to these copies exist).
---@class ThreadLocal<T>

---(Not exposed)
---The Throwable class is the superclass of all errors and
--- exceptions in the Java language. Only objects that are instances of this
--- class (or one of its subclasses) are thrown by the Java Virtual Machine or
--- can be thrown by the Java throw statement. Similarly, only
--- this class or one of its subclasses can be the argument type in a
--- catch clause.
---
--- For the purposes of compile-time checking of exceptions,
--- Throwable and any subclass of Throwable that is not also a
--- subclass of either RuntimeException or Error are
--- regarded as checked exceptions.
---
--- Instances of two subclasses, Error and
--- Exception, are conventionally used to indicate
--- that exceptional situations have occurred. Typically, these instances
--- are freshly created in the context of the exceptional situation so
--- as to include relevant information (such as stack trace data).
---
--- A throwable contains a snapshot of the execution stack of its
--- thread at the time it was created. It can also contain a message
--- string that gives more information about the error. Over time, a
--- throwable can suppress other
--- throwables from being propagated.  Finally, the throwable can also
--- contain a cause: another throwable that caused this
--- throwable to be constructed.  The recording of this causal information
--- is referred to as the chained exception facility, as the
--- cause can, itself, have a cause, and so on, leading to a "chain" of
--- exceptions, each caused by another.
---
--- One reason that a throwable may have a cause is that the class that
--- throws it is built atop a lower layered abstraction, and an operation on
--- the upper layer fails due to a failure in the lower layer.  It would be bad
--- design to let the throwable thrown by the lower layer propagate outward, as
--- it is generally unrelated to the abstraction provided by the upper layer.
--- Further, doing so would tie the API of the upper layer to the details of
--- its implementation, assuming the lower layer's exception was a checked
--- exception.  Throwing a "wrapped exception" (i.e., an exception containing a
--- cause) allows the upper layer to communicate the details of the failure to
--- its caller without incurring either of these shortcomings.  It preserves
--- the flexibility to change the implementation of the upper layer without
--- changing its API (in particular, the set of exceptions thrown by its
--- methods).
---
--- A second reason that a throwable may have a cause is that the method
--- that throws it must conform to a general-purpose interface that does not
--- permit the method to throw the cause directly.  For example, suppose
--- a persistent collection conforms to the Collection interface, and that its persistence is implemented atop
--- java.io.  Suppose the internals of the add method
--- can throw an IOException.  The implementation
--- can communicate the details of the IOException to its caller
--- while conforming to the Collection interface by wrapping the
--- IOException in an appropriate unchecked exception.  (The
--- specification for the persistent collection should indicate that it is
--- capable of throwing such exceptions.)
---
--- A cause can be associated with a throwable in two ways: via a
--- constructor that takes the cause as an argument, or via the
--- initCause(Throwable) method.  New throwable classes that
--- wish to allow causes to be associated with them should provide constructors
--- that take a cause and delegate (perhaps indirectly) to one of the
--- Throwable constructors that takes a cause.
---
--- Because the initCause method is public, it allows a cause to be
--- associated with any throwable, even a "legacy throwable" whose
--- implementation predates the addition of the exception chaining mechanism to
--- Throwable.
---
--- By convention, class Throwable and its subclasses have two
--- constructors, one that takes no arguments and one that takes a
--- String argument that can be used to produce a detail message.
--- Further, those subclasses that might likely have a cause associated with
--- them should have two more constructors, one that takes a
--- Throwable (the cause), and one that takes a
--- String (the detail message) and a Throwable (the
--- cause).
---@class Throwable

java.lang = {}
